
// Code generated by @open-rpc/generator DO NOT EDIT.
import { RequestManager, PostMessageWindowTransport, PostMessageIframeTransport, WebSocketTransport, HTTPTransport, Client, JSONRPCError } from "@open-rpc/client-js";
import _ from "lodash";
import { OpenrpcDocument as OpenRPC, MethodObject, ContentDescriptorObject } from "@open-rpc/meta-schema";
import { MethodCallValidator, MethodNotFoundError } from "@open-rpc/schema-utils-js";

/**
 *
 * Issued at timestamp
 *
 */
export type IssuedAt = number;
/**
 *
 * Expiration timestamp
 *
 */
export type Expiration = number;
/**
 *
 * Not valid before timestamp
 *
 */
export type NotValidBefore = number;
/**
 *
 * Issuer - Decentralized Identifier: https://w3c-ccg.github.io/did-primer/#the-format-of-a-did
 *
 */
export type Issuer = string;
/**
 *
 * Subject of the request, could be a nonce or uuid provided by the server.
 *
 */
export type Subject = string;
/**
 *
 * Audience
 *
 */
export type Audience = string;
/**
 *
 * Optiona, additional signed data
 *
 */
export type Additional = string;
/**
 *
 * DID TokenID
 *
 */
export type TokenID = string;
export type StringDoaGddGA = string;
export type Address = string;
/**
 *
 * JWT Token
 *
 */
export type StringAhqTyMBz = string;
export interface DIDTokenClaim {
  iat?: IssuedAt;
  ext?: Expiration;
  nbf?: NotValidBefore;
  iss?: Issuer;
  sub?: Subject;
  aud?: Audience;
  add?: Additional;
  tid?: TokenID;
  [k: string]: any;
}
/**
 *
 * random string data returned from auth required method
 *
 */
export type StringYQEGSIt6 = string;
/**
 *
 * Generated! Represents an alias to any of the provided schemas
 *
 */
export type AnyOfStringDoaGddGAAddressStringDoaGddGAStringAhqTyMBzDIDTokenClaimStringYQEGSIt6 = StringDoaGddGA | Address | StringAhqTyMBz | DIDTokenClaim | StringYQEGSIt6;
export type Login = (DIDTokenString: StringDoaGddGA) => Promise<StringAhqTyMBz>;
export type AuthLoginWithAddress = (address: Address) => Promise<DIDTokenClaim>;
export type AuthRequiredMethod = (JWTToken: StringDoaGddGA) => Promise<StringYQEGSIt6>;

export interface Options {
  transport: {
    type: "websocket" | "http" | "https" | "postmessagewindow" | "postmessageiframe";
    host: string;
    port: number;
    path?: string;
    protocol?: string;
  },
}

export class AuthenticationWithDID {
  public rpc: Client;
  public static openrpcDocument: OpenRPC = {"openrpc":"1.2.4","info":{"title":"Authentication with DID","version":"1.0.0"},"methods":[{"name":"login","description":"Logs in the user with a DID token","params":[{"name":"DIDTokenString","schema":{"type":"string","title":"string_doaGddGA"}}],"result":{"name":"JWTToken","description":"JWT Token for the user to use as a session.","schema":{"type":"string","description":"JWT Token"}}},{"name":"auth_login_with_address","description":"Prompts the user to login by signing a claim with their address","params":[{"name":"address","description":"address the user claims to own","schema":{"pattern":"^0x[a-fA-F\\d]{40}$","title":"address","type":"string"}}],"result":{"name":"claim","description":"the claim for the user to sign","schema":{"title":"DIDTokenClaim","type":"object","properties":{"iat":{"title":"IssuedAt","description":"Issued at timestamp","type":"number"},"ext":{"title":"Expiration","description":"Expiration timestamp","type":"number"},"nbf":{"title":"NotValidBefore","description":"Not valid before timestamp","type":"number"},"iss":{"title":"Issuer","description":"Issuer - Decentralized Identifier: https://w3c-ccg.github.io/did-primer/#the-format-of-a-did","type":"string","format":"^did:"},"sub":{"title":"Subject","description":"Subject of the request, could be a nonce or uuid provided by the server.","type":"string","format":"^did:"},"aud":{"title":"Audience","description":"Audience","type":"string","format":"^did:"},"add":{"title":"Additional","description":"Optiona, additional signed data","type":"string"},"tid":{"title":"TokenID","description":"DID TokenID","type":"string"}}}},"examples":[{"name":"exampleAuthLoginWithAddress","params":[{"name":"address","value":"0xA4d1e7f6642Df0330890c70372F3516797f11f2C"}],"result":{"name":"result","value":{"iat":1599245366,"ext":1599255366,"iss":"did:ethr:0xA4d1e7f6642Df0330890c70372F3516797f11f2C","sub":"did:sig.tools:login","aud":"did:sig.tools:8066696d-7fb1-4a45-91a6-d43890c5c131","nbf":1599245366,"tid":"a1997f88-71ca-4d96-b220-df372b65b07b"}}}]},{"name":"auth_required_method","description":"a route that requires a user to have recieved a JWT token from the login method","params":[{"name":"JWTToken","schema":{"type":"string","title":"string_doaGddGA"}}],"result":{"name":"authRequiredMethodResult","description":"Data returned from the authentication required method","schema":{"type":"string","description":"random string data returned from auth required method"}}}],"components":{"schemas":{"DIDTokenClaim":{"title":"DIDTokenClaim","type":"object","properties":{"iat":{"title":"IssuedAt","description":"Issued at timestamp","type":"number"},"ext":{"title":"Expiration","description":"Expiration timestamp","type":"number"},"nbf":{"title":"NotValidBefore","description":"Not valid before timestamp","type":"number"},"iss":{"title":"Issuer","description":"Issuer - Decentralized Identifier: https://w3c-ccg.github.io/did-primer/#the-format-of-a-did","type":"string","format":"^did:"},"sub":{"title":"Subject","description":"Subject of the request, could be a nonce or uuid provided by the server.","type":"string","format":"^did:"},"aud":{"title":"Audience","description":"Audience","type":"string","format":"^did:"},"add":{"title":"Additional","description":"Optiona, additional signed data","type":"string"},"tid":{"title":"TokenID","description":"DID TokenID","type":"string"}}}}}} ;
  public transport: HTTPTransport | WebSocketTransport | PostMessageWindowTransport | PostMessageIframeTransport;
  private validator: MethodCallValidator;
  private timeout: number | undefined;

  constructor(options: Options) {

    if (options.transport === undefined || options.transport.type === undefined) {
      throw new Error("Invalid constructor params");
    }
    const {type, host, port, protocol} = options.transport;
    let path = options.transport.path || "";
    if(path && path[0] !== "/") {
        path = "/" + path;
    }
    switch (type) {
      case 'http':
      case 'https':
        this.transport = new HTTPTransport((protocol || type) + "://" + host + ":" + port + path);
        break;
      case 'websocket':
        this.transport = new WebSocketTransport((protocol || "ws://") + host + ":" + port + path);
        break;
      case 'postmessageiframe':
        this.transport = new PostMessageIframeTransport(protocol + "://" + host + ":" + port + path);
        break;
      case 'postmessagewindow':
        this.transport = new PostMessageWindowTransport(protocol + "://" + host + ":" + port + path);
        break;
      default:
        throw new Error("unsupported transport");
        break;
    }
    this.rpc = new Client(new RequestManager([this.transport]));
    this.validator = new MethodCallValidator(AuthenticationWithDID.openrpcDocument);
  }
  /**
   * Adds a JSONRPC notification handler to handle receiving notifications.
   * @example
   * myClient.onNotification((data)=>console.log(data));
   */
  public onNotification(callback: (data: any) => void) {
    this.rpc.onNotification(callback);
  }

  /**
   * Adds an optional JSONRPCError handler to handle receiving errors that cannot be resolved to a specific request
   * @example
   * myClient.onError((err: JSONRPCError)=>console.log(err.message));
   */
  public onError(callback: (data: JSONRPCError) => void) {
     this.rpc.onError(callback);
  }

  /**
   * Sets a default timeout in ms for all requests excluding notifications.
   * @example
   * // 20s timeout
   * myClient.setDefaultTimeout(20000);
   * // Removes timeout from request
   * myClient.setDefaultTimeout(undefined);
   */
   public setDefaultTimeout(ms?: number) {
    this.timeout = ms;
  }

  /**
   * Initiates [[AuthenticationWithDID.startBatch]] in order to build a batch call.
   *
   * Subsequent calls to [[AuthenticationWithDID.request]] will be added to the batch.
   * Once [[AuthenticationWithDID.stopBatch]] is called, the promises for the [[AuthenticationWithDID.request]]
   * will then be resolved.  If there is already a batch in progress this method is a noop.
   *
   * @example
   * myClient.startBatch();
   * myClient.foo().then(() => console.log("foobar"))
   * myClient.bar().then(() => console.log("foobarbaz"))
   * myClient.stopBatch();
   */
  public startBatch(): void {
    return this.rpc.startBatch();
  }

  /**
   * Initiates [[Client.stopBatch]] in order to finalize and send the batch to the underlying transport.
   *
   * stopBatch will send the [[AuthenticationWithDID]] calls made since the last [[AuthenticationWithDID.startBatch]] call. For
   * that reason, [[AuthenticationWithDID.startBatch]] MUST be called before [[AuthenticationWithDID.stopBatch]].
   *
   * @example
   * myClient.startBatch();
   * myClient.foo().then(() => console.log("foobar"))
   * myClient.bar().then(() => console.log("foobarbaz"))
   * myClient.stopBatch();
   */
  public stopBatch(): void {
    return this.rpc.stopBatch();
  }

  private request(methodName: string, params: any[]): Promise<any> {
    const methodObject = _.find(AuthenticationWithDID.openrpcDocument.methods, ({name}) => name === methodName) as MethodObject;
    const notification = methodObject.result ? false : true;
    const openRpcMethodValidationErrors = this.validator.validate(methodName, params);
    if ( openRpcMethodValidationErrors instanceof MethodNotFoundError || openRpcMethodValidationErrors.length > 0) {
      return Promise.reject(openRpcMethodValidationErrors);
    }

    let rpcParams;
    if (methodObject.paramStructure && methodObject.paramStructure === "by-name") {
      rpcParams = _.zipObject(params, _.map(methodObject.params, "name"));
    } else {
      rpcParams = params;
    }
    if (notification) {
      return this.rpc.notify({method: methodName, params: rpcParams});
    }
    return this.rpc.request({method: methodName, params: rpcParams}, this.timeout);
  }

  
  /**
   * 
   */
  // tslint:disable-next-line:max-line-length
  public login: Login = (...params) => {
    return this.request("login", params);
  }
  
  /**
   * 
   */
  // tslint:disable-next-line:max-line-length
  public auth_login_with_address: AuthLoginWithAddress = (...params) => {
    return this.request("auth_login_with_address", params);
  }
  
  /**
   * 
   */
  // tslint:disable-next-line:max-line-length
  public auth_required_method: AuthRequiredMethod = (...params) => {
    return this.request("auth_required_method", params);
  }
  
}
export default AuthenticationWithDID;
